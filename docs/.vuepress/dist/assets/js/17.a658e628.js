(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{224:function(t,s,a){"use strict";a.r(s);var e=a(0),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"event-loop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-loop"}},[t._v("#")]),t._v(" Event-Loop")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#同步-异步-多线程"}},[t._v("同步 & 异步 & 多线程")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"同步-异步-多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步-异步-多线程"}},[t._v("#")]),t._v(" 同步 & 异步 & 多线程")]),t._v(" "),a("p",[a("strong",[t._v("同步与异步的区别")])]),t._v(" "),a("p",[t._v("同步（Synchronous）：在执行某个操作时，应用程序必须等待该操作执行完成后才能继续执行。\n异步（Asynchronous）：在执行某个操作时，应用程序可在异步操作执行时继续执行。实质：异步操作，启动了新的，线程主线程与方法线程并行执行。异步任务是不会进入主线程，而是会先进入任务队列")]),t._v(" "),a("p",[a("strong",[t._v("异步和多线程的区别")])]),t._v(" "),a("p",[a("code",[t._v("我们已经知道")]),t._v("， 异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。 异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。")]),t._v(" "),a("p",[t._v("简单的说就是：异步线程是由线程池负责管理，而多线程，我们可以自己控制，当然在多线程中我们也可以使用线程池。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code")])])])}),[],!1,null,null,null);s.default=n.exports}}]);